/**
 * based on string passed, get the integer hash value
 * through bitwise operation (based on spinoff of dbj2
 * with enhancements for reduced collisions)
 *
 * @param string the string to get the hash value for
 * @returns the hash value
 */
function getUniqueIntegerFromString(string) {
  var index = string.length;
  var hashA = 5381;
  var hashB = 52711;
  var charCode;

  while (index--) {
    charCode = string.charCodeAt(index);
    hashA = hashA * 33 ^ charCode;
    hashB = hashB * 33 ^ charCode;
  }

  return (hashA >>> 0) * 4096 + (hashB >>> 0);
}

var _OBJECT_CLASS, _BAILOUT_TAGS, _ITERABLE_TAGS, _SELF_TAGS, _TO_STRING_TAGS, _TYPED_ARRAY_TAGS;

var OBJECT_CLASS_TYPE;

(function (OBJECT_CLASS_TYPE) {
  OBJECT_CLASS_TYPE["Arguments"] = "[object Arguments]";
  OBJECT_CLASS_TYPE["Array"] = "[object Array]";
  OBJECT_CLASS_TYPE["ArrayBuffer"] = "[object ArrayBuffer]";
  OBJECT_CLASS_TYPE["Boolean"] = "[object Boolean]";
  OBJECT_CLASS_TYPE["DataView"] = "[object DataView]";
  OBJECT_CLASS_TYPE["Date"] = "[object Date]";
  OBJECT_CLASS_TYPE["DocumentFragment"] = "[object DocumentFragment]";
  OBJECT_CLASS_TYPE["Error"] = "[object Error]";
  OBJECT_CLASS_TYPE["Event"] = "[object Event]";
  OBJECT_CLASS_TYPE["Float32Array"] = "[object Float32Array]";
  OBJECT_CLASS_TYPE["Float64Array"] = "[object Float64Array]";
  OBJECT_CLASS_TYPE["Function"] = "[object Function]";
  OBJECT_CLASS_TYPE["Generator"] = "[object Generator]";
  OBJECT_CLASS_TYPE["GeneratorFunction"] = "[object GeneratorFunction]";
  OBJECT_CLASS_TYPE["HTMLElement"] = "[object HTMLElement]";
  OBJECT_CLASS_TYPE["Int8Array"] = "[object Int8Array]";
  OBJECT_CLASS_TYPE["Int16Array"] = "[object Int16Array]";
  OBJECT_CLASS_TYPE["Int32Array"] = "[object Int32Array]";
  OBJECT_CLASS_TYPE["Map"] = "[object Map]";
  OBJECT_CLASS_TYPE["Null"] = "[object Null]";
  OBJECT_CLASS_TYPE["Number"] = "[object Number]";
  OBJECT_CLASS_TYPE["Object"] = "[object Object]";
  OBJECT_CLASS_TYPE["Promise"] = "[object Promise]";
  OBJECT_CLASS_TYPE["RegExp"] = "[object RegExp]";
  OBJECT_CLASS_TYPE["Set"] = "[object Set]";
  OBJECT_CLASS_TYPE["String"] = "[object String]";
  OBJECT_CLASS_TYPE["Symbol"] = "[object Symbol]";
  OBJECT_CLASS_TYPE["Uint8Array"] = "[object Uint8Array]";
  OBJECT_CLASS_TYPE["Uint8ClampedArray"] = "[object Uint8ClampedArray]";
  OBJECT_CLASS_TYPE["Uint16Array"] = "[object Uint16Array]";
  OBJECT_CLASS_TYPE["Uint32Array"] = "[object Uint32Array]";
  OBJECT_CLASS_TYPE["Undefined"] = "[object Undefined]";
  OBJECT_CLASS_TYPE["WeakMap"] = "[object WeakMap]";
  OBJECT_CLASS_TYPE["WeakSet"] = "[object WeakSet]";
  OBJECT_CLASS_TYPE["Window"] = "[object Window]";
})(OBJECT_CLASS_TYPE || (OBJECT_CLASS_TYPE = {}));

var OBJECT_CLASS = (_OBJECT_CLASS = {}, _OBJECT_CLASS[OBJECT_CLASS_TYPE.Arguments] = 'Arguments', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Array] = 'Array', _OBJECT_CLASS[OBJECT_CLASS_TYPE.ArrayBuffer] = 'ArrayBuffer', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Boolean] = 'Boolean', _OBJECT_CLASS[OBJECT_CLASS_TYPE.DataView] = 'DataView', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Date] = 'Date', _OBJECT_CLASS[OBJECT_CLASS_TYPE.DocumentFragment] = 'DocumentFragment', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Error] = 'Error', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Event] = 'Event', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Float32Array] = 'Float32Array', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Float64Array] = 'Float64Array', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Function] = 'Function', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Generator] = 'Generator', _OBJECT_CLASS[OBJECT_CLASS_TYPE.GeneratorFunction] = 'GeneratorFunction', _OBJECT_CLASS[OBJECT_CLASS_TYPE.HTMLElement] = 'HTMLElement', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Int8Array] = 'Int8Array', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Int16Array] = 'Int16Array', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Int32Array] = 'Int32Array', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Map] = 'Map', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Null] = 'Null', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Number] = 'Number', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Object] = 'Object', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Promise] = 'Promise', _OBJECT_CLASS[OBJECT_CLASS_TYPE.RegExp] = 'RegExp', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Set] = 'Set', _OBJECT_CLASS[OBJECT_CLASS_TYPE.String] = 'String', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Symbol] = 'Symbol', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Uint8Array] = 'Uint8Array', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Uint8ClampedArray] = 'Uint8ClampedArray', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Uint16Array] = 'Uint16Array', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Uint32Array] = 'Uint32Array', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Undefined] = 'Undefined', _OBJECT_CLASS[OBJECT_CLASS_TYPE.WeakMap] = 'WeakMap', _OBJECT_CLASS[OBJECT_CLASS_TYPE.WeakSet] = 'WeakSet', _OBJECT_CLASS[OBJECT_CLASS_TYPE.Window] = 'Window', _OBJECT_CLASS);
var BAILOUT_TAGS = (_BAILOUT_TAGS = {}, _BAILOUT_TAGS[OBJECT_CLASS_TYPE.Generator] = true, _BAILOUT_TAGS[OBJECT_CLASS_TYPE.Promise] = true, _BAILOUT_TAGS[OBJECT_CLASS_TYPE.WeakMap] = true, _BAILOUT_TAGS[OBJECT_CLASS_TYPE.WeakSet] = true, _BAILOUT_TAGS);
var ITERABLE_TAGS = (_ITERABLE_TAGS = {}, _ITERABLE_TAGS[OBJECT_CLASS_TYPE.Map] = true, _ITERABLE_TAGS[OBJECT_CLASS_TYPE.Set] = true, _ITERABLE_TAGS);
var PRIMITIVE_TAGS = {
  bigint: true,
  boolean: true,
  function: true,
  number: true,
  string: true,
  undefined: true
};
var SELF_TAGS = (_SELF_TAGS = {}, _SELF_TAGS[OBJECT_CLASS_TYPE.Arguments] = true, _SELF_TAGS[OBJECT_CLASS_TYPE.Array] = true, _SELF_TAGS);
var TO_STRING_TAGS = (_TO_STRING_TAGS = {}, _TO_STRING_TAGS[OBJECT_CLASS_TYPE.RegExp] = true, _TO_STRING_TAGS[OBJECT_CLASS_TYPE.Symbol] = true, _TO_STRING_TAGS);
var TYPED_ARRAY_TAGS = (_TYPED_ARRAY_TAGS = {}, _TYPED_ARRAY_TAGS[OBJECT_CLASS_TYPE.Float32Array] = true, _TYPED_ARRAY_TAGS[OBJECT_CLASS_TYPE.Float64Array] = true, _TYPED_ARRAY_TAGS[OBJECT_CLASS_TYPE.Int8Array] = true, _TYPED_ARRAY_TAGS[OBJECT_CLASS_TYPE.Int16Array] = true, _TYPED_ARRAY_TAGS[OBJECT_CLASS_TYPE.Int32Array] = true, _TYPED_ARRAY_TAGS[OBJECT_CLASS_TYPE.Uint8Array] = true, _TYPED_ARRAY_TAGS[OBJECT_CLASS_TYPE.Uint8ClampedArray] = true, _TYPED_ARRAY_TAGS[OBJECT_CLASS_TYPE.Uint16Array] = true, _TYPED_ARRAY_TAGS[OBJECT_CLASS_TYPE.Uint32Array] = true, _TYPED_ARRAY_TAGS);

var HAS_BUFFER_FROM_SUPPORT = typeof Buffer !== 'undefined' && typeof Buffer.from === 'function';
var HAS_UINT16ARRAY_SUPPORT = typeof Uint16Array === 'function';
/**
 * get the string value of the buffer passed based on a Buffer
 *
 * @param buffer the array buffer to convert
 * @returns the stringified buffer
 */

function getStringifiedArrayBufferFallback(buffer) {
  return String.fromCharCode.apply(null, new Uint16Array(buffer));
}
/**
 * get the string value of the buffer passed based on a Uint16Array
 *
 * @param buffer the array buffer to convert
 * @returns the stringified buffer
 */

function getStringifiedArrayBufferModern(buffer) {
  return Buffer.from(buffer).toString('utf8');
}
/**
 * return a placeholder when no arraybuffer support exists
 *
 * @returns the placeholder
 */
// eslint-disable-next-line @typescript-eslint/no-unused-vars

function getStringifiedArrayBufferNoSupport(buffer) {
  return '';
}
/**
 * @function getStringifiedArrayBuffer
 *
 * @description
 * get the string value of the buffer passed
 *
 * @param {ArrayBuffer} buffer the array buffer to convert
 * @returns {string} the stringified buffer
 */

var getStringifiedArrayBuffer = function () {
  if (HAS_BUFFER_FROM_SUPPORT) {
    return getStringifiedArrayBufferModern;
  }

  if (HAS_UINT16ARRAY_SUPPORT) {
    return getStringifiedArrayBufferFallback;
  }

  return getStringifiedArrayBufferNoSupport;
}();

var FUNCTION_NAME_REGEX = /^\s*function\s*([^(]*)/i;
var HTML_ELEMENT_REGEXP = /\[object (HTML(.*)Element)\]/;
var SVG_ELEMENT_REGEXP = /\[object (SVG(.*)Element)\]/;
var toString = Object.prototype.toString;
var keys = Object.keys;
/**
 * get the name of the function based on a series of fallback attempts
 *
 * @param fn the function to test
 * @returns the function name
 */
// eslint-disable-next-line @typescript-eslint/ban-types

function getConstructorName(fn) {
  return fn.name || (fn.toString().match(FUNCTION_NAME_REGEX) || [])[1] || 'anonymous';
}
/**
 * get the event object sorted by its properties
 *
 * @param event the event to sort
 * @returns the event object with all properties sorted
 */


function getSortedEvent(event) {
  return {
    bubbles: event.bubbles,
    cancelBubble: event.cancelBubble,
    cancelable: event.cancelable,
    composed: event.composed,
    currentTarget: event.currentTarget,
    defaultPrevented: event.defaultPrevented,
    eventPhase: event.eventPhase,
    isTrusted: event.isTrusted,
    returnValue: event.returnValue,
    target: event.target,
    type: event.type
  };
}
/**
 * get the sort result based on the two values to compare
 *
 * @param first the first value to compare
 * @param second the second value to compare
 * @returns should the value be sorted
 */


function shouldSort(first, second) {
  return first > second;
}
/**
 * get the sort result based on the two pairs to compare
 *
 * @param firstPair the first pair to compare
 * @param secondPair the second pair to compare
 * @returns should the value be sorted
 */


function shouldSortPair(firstPair, secondPair) {
  return firstPair[0] > secondPair[0];
}
/**
 * sort the array based on the fn passed
 *
 * @param array the array to sort
 * @param fn the sorting function
 * @returns the sorted array
 */


function sort(array, fn) {
  var subIndex;
  var value;

  for (var index = 0; index < array.length; ++index) {
    value = array[index];

    for (subIndex = index - 1; ~subIndex && fn(array[subIndex], value); --subIndex) {
      array[subIndex + 1] = array[subIndex];
    }

    array[subIndex + 1] = value;
  }

  return array;
}
/**
 * get the pairs in the iterable for stringification
 *
 * @param iterable the iterable to get the pairs for
 * @returns the sorted, stringified entries
 */


function getSortedIterable(iterable, cache, keys) {
  var isMap = iterable instanceof Map;
  var entries = [];

  if (isMap) {
    iterable.forEach(function (value, key) {
      entries.push([stringify(key, cache, keys), stringify(value, cache, keys)]);
    });
    sort(entries, shouldSortPair);
  } else {
    iterable.forEach(function (value) {
      entries.push(stringify(value, cache, keys));
    });
    sort(entries, shouldSort);
  }

  var _final = getConstructorName(iterable.constructor) + "|[";

  for (var index = 0, length = entries.length, entry; index < length; ++index) {
    entry = entries[index];
    _final += "" + (index ? ',' : '') + (isMap ? "[" + entry[0] + "," + entry[1] + "]" : entry);
  }

  return _final + "]";
}
/**
 * get the object with the keys sorted
 *
 * @param object the object to sort
 * @returns the sorted object
 */


function getSortedObject(object) {
  var objectKeys = sort(keys(object), shouldSort);
  var newObject = {};
  var key;

  for (var index = 0; index < objectKeys.length; ++index) {
    key = objectKeys[index];
    newObject[key] = object[key];
  }

  return newObject;
}
/**
 * build a string based on all the fragment's children
 *
 * @param fragment the fragment to stringify
 * @returns the stringified fragment
 */


function getStringifiedDocumentFragment(fragment) {
  var children = fragment.children;
  var innerHTML = '';

  for (var index = 0; index < children.length; ++index) {
    innerHTML += children[index].outerHTML;
  }

  return innerHTML;
}
/**
 * get the index after that of the value match in the array (faster than
 * native indexOf) to determine the cutoff index for the `splice()` call.
 *
 * @param array the array to get the index of the value at
 * @param value the value to match
 * @returns the index after the value match in the array
 */


function getCutoffIndex(array, value) {
  for (var index = 0; index < array.length; ++index) {
    if (array[index] === value) {
      return index + 1;
    }
  }

  return 0;
}
/**
 * get the value normalized for stringification
 *
 * @param value the value to normalize
 * @param sortedCache the cache of sorted objects
 * @param passedTag the previously-calculated tag
 * @returns the normalized value
 */


function getNormalizedValue(value, cache, keys, passedTag) {
  if (!passedTag) {
    var type = typeof value;

    if (type === 'string' || PRIMITIVE_TAGS[type]) {
      return type + "|" + value;
    }

    if (value === null) {
      return "null|" + value;
    }
  }

  var tag = passedTag || toString.call(value);

  if (SELF_TAGS[tag]) {
    return value;
  }

  if (tag === OBJECT_CLASS_TYPE.Object) {
    return getSortedObject(value);
  }

  if (TO_STRING_TAGS[tag]) {
    return OBJECT_CLASS[tag] + "|" + value.toString();
  }

  if (ITERABLE_TAGS[tag]) {
    return getSortedIterable(value, cache, keys);
  }

  if (tag === OBJECT_CLASS_TYPE.Date) {
    return OBJECT_CLASS[tag] + "|" + value.getTime();
  }

  if (tag === OBJECT_CLASS_TYPE.Error) {
    return OBJECT_CLASS[tag] + "|" + value.stack;
  }

  if (tag === OBJECT_CLASS_TYPE.Event) {
    return getSortedEvent(value);
  }

  if (BAILOUT_TAGS[tag]) {
    return OBJECT_CLASS[tag] + "|NOT_ENUMERABLE";
  }

  if (HTML_ELEMENT_REGEXP.test(tag) || SVG_ELEMENT_REGEXP.test(tag)) {
    return tag.slice(8, -1) + "|" + value.outerHTML;
  }

  if (tag === OBJECT_CLASS_TYPE.DocumentFragment) {
    return OBJECT_CLASS[tag] + "|" + getStringifiedDocumentFragment(value);
  }

  if (TYPED_ARRAY_TAGS[tag]) {
    return OBJECT_CLASS[tag] + "|" + value.join(',');
  }

  if (tag === OBJECT_CLASS_TYPE.ArrayBuffer) {
    return OBJECT_CLASS[tag] + "|" + getStringifiedArrayBuffer(value);
  }

  if (tag === OBJECT_CLASS_TYPE.DataView) {
    return OBJECT_CLASS[tag] + "|" + getStringifiedArrayBuffer(value.buffer);
  }

  return value;
}
/**
 * create the replacer function used for stringification
 *
 * @param sortedCache the cache to use for sorting objects
 * @returns function getting the normalized value
 */


function createReplacer(cache, keys) {
  if (cache === void 0) {
    cache = [];
  }

  if (keys === void 0) {
    keys = [];
  }

  return function (key, value) {
    if (typeof value === 'object') {
      if (cache.length) {
        var thisCutoff = getCutoffIndex(cache, this);

        if (thisCutoff === 0) {
          cache.push(this);
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }

        keys.push(key);
        var valueCutoff = getCutoffIndex(cache, value);

        if (valueCutoff !== 0) {
          return "[~" + (keys.slice(0, valueCutoff).join('.') || '.') + "]";
        }

        cache.push(value);
      } else {
        cache[0] = value;
        keys[0] = key;
      }
    }

    if (key && this[key] instanceof Date) {
      return getNormalizedValue(this[key], cache, keys, OBJECT_CLASS_TYPE.Date);
    }

    return getNormalizedValue(value, cache, keys);
  };
}
/**
 * stringify the value based on the options passed
 *
 * @param value the value to stringify
 * @returns the stringified value
 */


function stringify(value, cache, keys) {
  if (!value || typeof value !== 'object') {
    return getNormalizedValue(value, cache, keys);
  }

  var tag = toString.call(value);

  if (tag === OBJECT_CLASS_TYPE.Date || tag === OBJECT_CLASS_TYPE.RegExp) {
    return getNormalizedValue(value, cache, keys, tag);
  }

  return JSON.stringify(value, createReplacer(cache, keys));
}

/**
 * hash the value passed to a unique, consistent hash value
 *
 * @param value the value to hash
 * @returns the object hash
 */

function hash(value) {
  return getUniqueIntegerFromString(stringify(value));
}

function is(value, otherValue) {
  return hash(value) === hash(otherValue);
}

function isAll(value) {
  for (var index = 0; index < (arguments.length <= 1 ? 0 : arguments.length - 1); ++index) {
    if (!is(value, index + 1 < 1 || arguments.length <= index + 1 ? undefined : arguments[index + 1])) {
      return false;
    }
  }

  return true;
}

function isAny(value) {
  for (var index = 0; index < (arguments.length <= 1 ? 0 : arguments.length - 1); ++index) {
    if (is(value, index + 1 < 1 || arguments.length <= index + 1 ? undefined : arguments[index + 1])) {
      return true;
    }
  }

  return false;
}

function isNot(value, otherValue) {
  return hash(value) !== hash(otherValue);
}

is.all = isAll;
is.any = isAny;
is.not = isNot;
hash.is = is;

export default hash;
//# sourceMappingURL=hash-it.esm.js.map
